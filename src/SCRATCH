const predicateIndexesLowest = ({ indexes, lowestValue, index }, value) => {
	if (value < lowestValue) {
		return { indexes: [index], lowestValue: value, index: index + 1 };
	}
	else if (value == lowestValue) {
		return { indexes: indexes.concat([index]), lowestValue: lowestValue, index: index + 1 };
	}
	else {
		return { indexes: indexes, lowestValue: lowestValue, index: index + 1};
	}
};
const getIndexesLowest = (intList) => (foldl(intList, predicateIndexesLowest, { indexes: [], lowestValue: Infinity, index: 0 }).indexes);

const predicateIndexesHighest = ({ indexes, highestValue, index }, value) => {
	if (value > highestValue) {
		return { indexes: [index], highestValue: value, index: index + 1 };
	}
	else if (value == highestValue) {
		return { indexes: indexes.concat([index]), highestValue: highestValue, index: index + 1 };
	}
	else {
		return { indexes: indexes, highestValue: highestValue, index: index + 1 };
	}
};
const getIndexesHighest = (intList) => (foldl(intList, predicateIndexesHighest, { indexes: [], highestValue: -Infinity, index: 0 }).indexes);

const getIndexesAll = (intList) => (intList.map((value, index) => index));

const predicateIndexesZeroes = ({ indexes, index }, value) => {
	if (value == 0) {
		return { indexes: indexes.concat([index]), index: index + 1 };
	}
	else {
		return { indexes: indexes, index: index + 1};
	}
};
const getIndexesZeroes = (intList) => (foldl(intList, predicateIndexesZeroes, { indexes: [], index: 0 }).indexes);

const predicateIndexesPositive = ({ indexes, index }, value) => {
	if (value > 0) {
		return { indexes: indexes.concat([index]), index: index + 1 };
	}
	else {
		return { indexes: indexes, index: index + 1};
	}
};
const getIndexesPositive = (intList) => (foldl(intList, predicateIndexesPositive, { indexes: [], index: 0 }).indexes);

const predicateMaximalHint = ({ highestValue, hints }, { value, hint }) => {
	if (value > highestValue) {
		return { hints: [hint], highestValue: value };
	}
	else if (value == highestValue) {
		return { hints: hints.concat([hint]), highestValue: highestValue };
	}
	else {
		return { hints: hints, highestValue: highestValue };
	}
};
const getMaximalHint = (hintList) => (foldl(hintList, predicateMaximalHint, { hints: [hintList[0].hint], highestValue: hintList[0].value }).hints);

const predicateMinimalHint = ({ lowestValue, hints }, { value, hint }) => {
	if (value < lowestValue) {
		return { hints: [hint], lowestValue: value };
	}
	else if (value == lowestValue) {
		return { hints: hints.concat([hint]), lowestValue: lowestValue };
	}
	else {
		return { hints: hints, lowestValue: lowestValue };
	}
};
const getMinimalHint = (hintList) => (foldl(hintList, predicateMinimalHint, { hints: [hintList[0].hint], lowestValue: hintList[0].value }).hints);

const countNegatives = (elementList, indexSelection) => {
	const predicateCountNegatives = (accu, index) => (elementList[index] < 0 ? accu + 1 : accu);
	return (foldl(indexSelection, predicateCountNegatives, 0));
};

const countZeroes = (elementList, indexSelection) => {
	const predicateCountZeroes = (accu, index) => (elementList[index] == 0 ? accu + 1 : accu);
	return foldl(indexSelection, predicateCountZeroes, 0);
}

const predicateMinimum = (accu, value) => (value < accu ? value : accu);
const getMinimum = (intList) => (foldl(intList, predicateMinimum, intList[0]));

const predicateMaximum = (accu, {index, value}) => (value > accu ? value : accu);
const getMaximum = (intList) => (foldl(intList, predicateMaximum, intList[0]));
